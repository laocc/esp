<?phpnamespace esp\core;/** * Class Session * @package plugins\ext * * * 若某页面原则上是不会改变任何session，为保险起见，可在页面任何地方加：session_abort();用于丢弃当前进程所有对session的改动； * * 本类只是改变PHP存取session的介质，在使用方面没有影响，如：$_SESSION['v']=123，$v=$_SESSION['v']； * 同时也可用Yaf Session的方法应用，Yaf Session为对PHP存取session的一些方法进行封装。 * * 本插件实现用redis保存session，且每个session的生存期从其自身被定义时计算起，而非PHP本身统一设置 * 有一个问题须注意：$_SESSION['name']=abc；之后若再次给$_SESSION['name']赋其他不同的值，则其生存期以第二次赋值起算起 * 但是，若第二次赋值与之前的值相同，并不会改变其生存期 * * * 如果只是想存到redis也可以直接设置，或修改php.ini * ini_set(“session.save_handler”,”redis”); * ini_set(“session.save_path”,”tcp://127.0.0.1:6379″); */final class Session{    public static function init()    {        if (_CLI) return;        $config = Config::get('session');        if (!$config['driver'] or !in_array($config['driver'], ['php', 'redis', 'memcache'])) return;        if (!$config['expire']) {            error('Session Expire 必须设置，且要求大于0。');        }        if (session_status() === PHP_SESSION_DISABLED) {            error('Session: 异常，可能session已被禁止，在编译PHP时不带--disable-session可恢复启用');        } elseif (session_status() === PHP_SESSION_ACTIVE or (bool)ini_get('session.auto_start')) {            error('Session: session已启动，请关闭php.ini中的session.auto_start');        }        if (isset($_GET['session_id']) and preg_match('/^[a-z][a-z0-9]{25}$/i', $_GET['session_id'])) {            session_id($_GET['session_id']);        }        //设置cookies.name，若不设此值，则用php.ini中的相应值，只能使用字母和数字，且不可是全数字，不要与网站其他地方cookies重名        if (isset($config['cookie']) and $config['cookie'] and preg_match('/^[a-z][a-z0-9]*$/i', $config['cookie'])) {            session_name(strtoupper($config['cookie']));        }        //设置session调用cookies的参数，这里有效期尽可能大，因为session的有效期不依赖这个，这儿只是让session_id保存的更长久一点        session_set_cookie_params(999999999, '/', '.' . _HOST, _HTTPS, TRUE);        session_set_save_handler(new SessionHandler($config), true);        session_start();//        session_regenerate_id(false);    }    public static function set($key, $value, $ttl = 0)    {        $_SESSION[$key] = $value;    }    public static function del($key)    {        unset($_SESSION[$key]);    }    public static function get($key = null, $autoValue = null)    {        if ($key === null) return $_SESSION;        return isset($_SESSION[$key]) ? $_SESSION[$key] : $autoValue;    }    private static function check_status()    {        if (session_status() < 2) {            error('session_start() no start,run it first in \config\config.ini');        }    }}class SessionHandler implements \SessionHandlerInterface{    /**     * 本类实现将一个客户端的session存为redis的一个哈希表，其中有一个特例键值为完整session内容，所以该键名需特殊一点，     * 如用：_SESSION_VALUE_，则实际session中不能再用此键名，相当于这成了一个保留字。     * 在redis客户端中用hgetall $session_id可查看该表中所有内容     *     * 127.0.0.1:6379[2]> hgetall astu7vp14v1pkateglp1jevs23     */    const _SESSION_VALUE_ = '_SESSION_VALUE_';    private $expire;    private $memcache;    function __construct($config)    {        $this->expire = $config['expire'];        $driver = strtolower($config['driver']);        $db = $config[$driver] + Config::get('memcache');        $driver = '\esp\extend\db\\' . ucfirst($driver);        $this->memcache = new $driver($db);    }    /**     * 1,启动时运行，测试redis是否可用     * @param string $save_path     * @param string $session_id     * @return mixed     */    public function open($save_path, $session_id)    {        return $this->memcache->ping();    }    /**     * 2,系统调起，读取存在redis中的session     * @param string $session_id     * @return mixed     */    public function read($session_id)    {        return $this->memcache->get($session_id);    }    /**     * 删除一个会话     * @param string $session_id     * @return mixed     * session_destroy()     */    public function destroy($session_id)    {        $this->memcache->del($session_id);        return true;    }    /**     * 清空以前的会话     * @param int $maxlifetime     * @return bool     */    public function gc($maxlifetime)    {        return true;    }    /**     * session_write_close()     * 写，无论如何，页面最后收尾时都会执行write，还有close     * 如果当前页没有写session，则$session_data就是个空字符串     *     * @param string $session_id     * @param string $session_data     * @return mixed     */    public function write($session_id, $session_data)    {        $this->memcache->set($session_id, $session_data, $this->expire);        return true;    }    /**     * 关闭会话     * session_write_close被注册为register_shutdown_function     */    public function close()    {        $this->memcache->close();        return true;    }}