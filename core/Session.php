<?phpnamespace esp\core;use \Yaf\Config\Ini;use \Yaf\Registry;use \Yaf\Session as YS;/** * Class Session * @package plugins\ext * * * 若某页面原则上是不会改变任何session，为保险起见，可在页面任何地方加：session_abort();用于丢弃当前进程所有对session的改动； * * 本类只是改变PHP存取session的介质，在使用方面没有影响，如：$_SESSION['v']=123，$v=$_SESSION['v']； * 同时也可用Yaf Session的方法应用，Yaf Session为对PHP存取session的一些方法进行封装。 * * 本插件实现用redis保存session，且每个session的生存期从其自身被定义时计算起，而非PHP本身统一设置 * 有一个问题须注意：$_SESSION['name']=abc；之后若再次给$_SESSION['name']赋其他不同的值，则其生存期以第二次赋值起算起 * 但是，若第二次赋值与之前的值相同，并不会改变其生存期 * * * 如果只是想存到redis也可以直接设置，或修改php.ini * ini_set(“session.save_handler”,”redis”); * ini_set(“session.save_path”,”tcp://127.0.0.1:6379″); */final class Session{    public function __construct(Ini $config)    {        if (_CLI) return;        if (!$config->driver or !in_array($config->driver, ['php', 'redis', 'memcache'])) return;        if (!$config->expire) {            error('Session Expire 必须设置，且要求大于0。');        }        if (session_status() === PHP_SESSION_DISABLED) {            error('Session: 异常，可能session已被禁止，在编译PHP时不带--disable-session可恢复启用');        } elseif (session_status() === PHP_SESSION_ACTIVE or (bool)ini_get('session.auto_start')) {            error('Session: session已启动，请关闭php.ini中的session.auto_start');        }        if (isset($_GET['session_id']) and preg_match('/^[a-z][a-z0-9]{25}$/i', $_GET['session_id'])) {            session_id($_GET['session_id']);        }        //设置cookies.name，若不设此值，则用php.ini中的相应值，只能使用字母和数字，且不可是全数字，不要与网站其他地方cookies重名        if ($config->cookie and preg_match('/^[a-z][a-z0-9]*$/i', $config->cookie)) {            session_name(strtoupper($config->cookie));        }        //设置session调用cookies的参数，这里有效期尽可能大，因为session的有效期不依赖这个，这儿只是让session_id保存的更长久一点        session_set_cookie_params(999999999, '/', '.' . _HOST, _HTTPS, TRUE);        if ($config->driver === 'redis') {     //注册到session接口            session_set_save_handler(new Redis($config), true);        } elseif ($config->driver === 'memcache') {     //注册到session接口            session_set_save_handler(new Memcache($config), true);        }        YS::getInstance()->start();//        session_start();//        session_regenerate_id(false);    }}class Memcache implements \SessionHandlerInterface{    /**     * 本类实现将一个客户端的session存为redis的一个哈希表，其中有一个特例键值为完整session内容，所以该键名需特殊一点，     * 如用：_SESSION_VALUE_，则实际session中不能再用此键名，相当于这成了一个保留字。     * 在redis客户端中用hgetall $session_id可查看该表中所有内容     *     * 127.0.0.1:6379[2]> hgetall astu7vp14v1pkateglp1jevs23     */    const _SESSION_VALUE_ = '_SESSION_VALUE_';    private $config;    private $memcache;    function __construct(Ini $config)    {        $this->config = $config;        $this->memcache = new \db\Memcache($config->memcache);    }    /**     * 1,启动时运行，测试redis是否可用     * @param string $save_path     * @param string $session_id     * @return mixed     */    public function open($save_path, $session_id)    {        return $this->memcache->ping();    }    /**     * 2,系统调起，读取存在redis中的session     * @param string $session_id     * @return mixed     */    public function read($session_id)    {        return $this->memcache->get($session_id);    }    /**     * 删除一个会话     * @param string $session_id     * @return mixed     * session_destroy()     */    public function destroy($session_id)    {        $this->memcache->del($session_id);        return true;    }    /**     * 清空以前的会话     * @param int $maxlifetime     * @return bool     */    public function gc($maxlifetime)    {        return true;    }    /**     * session_write_close()     * 写，无论如何，页面最后收尾时都会执行write，还有close     * 如果当前页没有写session，则$session_data就是个空字符串     *     * @param string $session_id     * @param string $session_data     * @return mixed     */    public function write($session_id, $session_data)    {        $this->memcache->set($session_id, $session_data, $this->config->expire);        return true;    }    /**     * 关闭会话     * session_write_close被注册为register_shutdown_function     */    public function close()    {        $this->memcache->close();        return true;    }}class Redis implements \SessionHandlerInterface{    /**     * 本类实现将一个客户端的session存为redis的一个哈希表，其中有一个特例键值为完整session内容，所以该键名需特殊一点，     * 如用：_SESSION_VALUE_，则实际session中不能再用此键名，相当于这成了一个保留字。     * 在redis客户端中用hgetall $session_id可查看该表中所有内容     *     * 127.0.0.1:6379[2]> hgetall astu7vp14v1pkateglp1jevs23     */    const _SESSION_VALUE_ = '_SESSION_VALUE_';    private $config;    private $redis;    private $_session;    private $_session_id;    function __construct(Ini $config)    {        if (!class_exists('redis')) {            error('redis 扩展不存在，请检查。');        }        $this->config = $config;        $this->redis = new \db\Redis($config->redis);    }    /**     * 1,启动时运行，测试redis是否可用     * @param string $save_path     * @param string $session_id     * @return mixed     */    public function open($save_path, $session_id)    {        return $this->redis->ping();    }    /**     * 2,系统调起，读取存在redis中的session     * @param string $session_id     * @return mixed     */    public function read($session_id)    {        if ($this->config->fined) {            $this->_session_id = $session_id;            $session = $this->redis->table($session_id)->get(self::_SESSION_VALUE_);            $session = $this->clean($session);        } else {            $session = $this->redis->get($session_id);        }        return $session;    }    /**     * 3,程序调起，清理过期的session     * 须在session_start()之后调起     */    private function clean($session)    {        if (ini_get('session.serialize_handler') !== 'php_serialize') return $session;        $table = $this->redis->table($this->_session_id);        $all = $table->get('*');        unset($all[self::_SESSION_VALUE_]);        if (empty($all)) return null;        $arr = unserialize($session);        foreach ($all as $k => &$tll) {            if ($tll <= time()) {                unset($arr[$k]);                $table->del($k);            } else {                if (isset($arr[$k])) {                    $this->_session[$k] = ['ttl' => $tll, 'val' => $arr[$k]];                } else {                    $table->del($k);                }            }        }        return serialize($arr);    }    /**     * 删除一个会话     * @param string $session_id     * @return mixed     * session_destroy()     */    public function destroy($session_id)    {        $this->redis->del($session_id);        return true;    }    /**     * 清空以前的会话     * @param int $maxlifetime     * @return bool     */    public function gc($maxlifetime)    {        return true;    }    /**     * session_write_close()     * 写，无论如何，页面最后收尾时都会执行write，还有close     * 如果当前页没有写session，则$session_data就是个空字符串     *     * @param string $session_id     * @param string $session_data     * @return mixed     */    public function write($session_id, $session_data)    {        if ($this->config->fined) {            $table = $this->redis->table($session_id);            $table->set(self::_SESSION_VALUE_, $session_data);            $_new_keys = Registry::get('_session_new_keys');            if (!$_new_keys or !is_array($_new_keys)) $_new_keys = [];            /**             * 从session中读取单项，若不存在单项，或值被修改，则更新单项             */            $ttl = time() + $this->config->expire;            foreach ($_SESSION as $k => &$val) {                if ($k === self::_SESSION_VALUE_) error("the key {$k} can not be used.");                if ($this->config->again or ##全部重建                    !isset($this->_session[$k]) or ##新值                    isset($_new_keys[$k]) or ##被重新赋值过                    $val != $this->_session[$k]['val']  ##和原值不同                ) {                    if (isset($_new_keys[$k]) and $_new_keys[$k]) $ttl = time() + $_new_keys[$k];                    $table->set($k, $ttl);                }            }            $this->redis->expire($session_id, $this->config->expire);            return true;        } else {            $this->redis->set($session_id, $session_data, $this->config->expire);            return true;        }    }    /**     * 关闭会话     * session_write_close被注册为register_shutdown_function     */    public function close()    {        $this->redis->close();        return true;    }}