<?phpnamespace esp\core;use esp\extend\db\ext\Nosql;/** * Class Session * @package plugins\ext * * * 若某页面原则上是不会改变任何session，为保险起见，可在页面任何地方加：session_abort();用于丢弃当前进程所有对session的改动； * * 本类只是改变PHP存取session的介质，在使用方面没有影响，如：$_SESSION['v']=123，$v=$_SESSION['v']； * * 本插件实现用redis保存session，且每个session的生存期从其自身被定义时计算起，而非PHP本身统一设置 * 有一个问题须注意：$_SESSION['name']=abc；之后若再次给$_SESSION['name']赋其他不同的值，则其生存期以第二次赋值起算起 * 但是，若第二次赋值与之前的值相同，并不会改变其生存期 * * * 如果只是想存到redis也可以直接设置，或修改php.ini * ini_set('session.save_handler', 'redis'); * ini_set('session.save_path', 'tcp://127.0.0.1:6379'); */final class Session{    public static function init()    {        if (_CLI) return;        $config = Config::get('session');        if (!isset($config['driver']) or !in_array($config['driver'], ['php', 'redis', 'memcache', 'memcached'])) return;        if (!isset($config['expire']) or !$config['expire']) $config['expire'] = 20;        if (session_status() === PHP_SESSION_DISABLED) {            error('Session: 异常，可能session已被禁止，在编译PHP时不带--disable-session可恢复启用');        } elseif (session_status() === PHP_SESSION_ACTIVE or (bool)ini_get('session.auto_start')) {            error('Session: session已启动，请关闭php.ini中的session.auto_start');        }        //查找附在URL中的SessionID        if (isset($_GET[$config['urlKey']]) and preg_match('/^\w{26}$/', $_GET[$config['urlKey']])) {            session_id($_GET[$config['urlKey']]);        }        //设置cookies.name，若不设此值，则用php.ini中的相应值，只能使用字母和数字，且不可是全数字，不要与网站其他地方cookies重名        if (isset($config['cokKey']) and $config['cokKey']) {            session_name($config['cokKey']);        }        $db = $config[$config['driver']] + Config::get($config['driver']);        ini_set('session.save_handler', $config['driver']);        ini_set('session.save_path', "tcp://{$db['host']}:{$db['port']}");        ini_set('session.serialize_handler', 'php_serialize');        session_set_cookie_params(86400 * 365, '/', '.' . _HOST, _HTTPS, TRUE);        if (headers_sent($file, $line)) error("在{$file}[{$line}]行已有数据输出，Session无法启动");        //设置session调用cookies的参数，这里有效期尽可能大，因为session的有效期不依赖这个，这儿只是让session_id保存的更长久一点//        session_set_save_handler(new SessionHandler($config), true);        session_start();    }    /**     * @param null $newID     * @return string     * 换新的sessionID，参数必须为true，也就是换新ID后，原数据清空，否则会导至数据库暴增     */    public static function id($newID = null)    {        if ($newID) session_regenerate_id(true);        return session_id();    }    public static function set($key, $value)    {        $_SESSION[$key] = $value;    }    public static function del($key)    {        unset($_SESSION[$key]);    }    public static function get($key = null, $autoValue = null)    {        if ($key === null) return $_SESSION;        return isset($_SESSION[$key]) ? $_SESSION[$key] : $autoValue;    }    private static function check_status()    {        if (session_status() < 2) {            error('session_start() no start,run it first in \config\config.ini');        }    }}class SessionHandler implements \SessionHandlerInterface{    /**     * 在redis客户端中用hgetall $session_id可查看该表中所有内容     *     * 127.0.0.1:6379[2]> hgetall astu7vp14v1pkateglp1jevs23     */    private $_expire;    private $_DB;    function __construct($config)    {        $driver = strtolower($config['driver']);        $DB = '\esp\extend\db\\' . ucfirst($driver);        $this->_DB = new $DB($config[$driver]);        $this->_DB instanceof Nosql and 1;        $this->_expire = $config['expire'];    }    /**     * 1,启动时运行，测试redis是否可用     * @param string $save_path     * @param string $session_id     * @return mixed     */    public function open($save_path, $session_id)    {        return $this->_DB->ping();    }    /**     * 2,系统调起，读取存在redis中的session     * @param string $session_id     * @return mixed     */    public function read($session_id)    {        $all = $this->_DB->get($session_id);        pre($all);        return $all;    }    /**     * 删除一个会话     * @param string $session_id     * @return mixed     * session_destroy()     */    public function destroy($session_id)    {        $this->_DB->del($session_id);        return true;    }    /**     * 清空以前的会话     * @param int $maxlifetime     * @return bool     */    public function gc($maxlifetime)    {        return true;    }    /**     * session_write_close()     * 写，无论如何，页面最后收尾时都会执行write，还有close     * 如果当前页没有写session，则$session_data就是个空字符串     *     * @param string $session_id     * @param string $session_data     * @return mixed     */    public function write($session_id, $session_data)    {//        pre([$session_id, $session_data, $this->_expire, $this->_DB->ping()]);        $this->_DB->set($session_id, $session_data, $this->_expire);        return true;    }    /**     * 关闭会话     * session_write_close被注册为register_shutdown_function     */    public function close()    {        $this->_DB->close();        return true;    }}